(()=>{var __webpack_modules__={"./src/js/btoc.js":()=>{eval("function Btoc(tocList, contentElement) {\r\n  this.tocList = tocList\r\n  this.elementList = getChild(contentElement, this.tocList)\r\n  // 当前解析到第几个标签\r\n  this.eIndex = 0\r\n\r\n  /**\r\n     * 递归读取目标标签中所有的符合要求的标签\r\n     * @param element\r\n     * @param tocList\r\n     * @returns {any[]|null}\r\n     */\r\n  function getChild(element, tocList) {\r\n    if (element == null) {\r\n      return null\r\n    }\r\n    // 获取所有子元素\r\n    var child = element.children\r\n    if (child.length === 0) {\r\n      return null\r\n    }\r\n    var childs = []\r\n    for (var i = 0; i < child.length; i++) {\r\n      var elem = child[i]\r\n      if (tocList.indexOf(elem.tagName) !== -1) {\r\n        childs.push(elem)\r\n      }\r\n      childs.push.apply(childs, getChild(elem, tocList))\r\n    }\r\n    return childs\r\n  }\r\n\r\n  /**\r\n     * 生成目录\r\n     */\r\n  this.build = function () {\r\n    if (this.elementList == null || this.elementList.length === 0) {\r\n      return ''\r\n    }\r\n    // 解析获取到的标签元素为目录\r\n    // 设置当前元素的最小度为-1表示当前元素为最外层目录元素，防止后续出现比当前元素序号更小的标签\r\n    return this.analysis(-1, this.tocList.indexOf(this.elementList[this.eIndex].tagName))\r\n  }\r\n\r\n  /**\r\n     * 解析目录\r\n     * @param last 最小的标签（即上级目录的标签）\r\n     * @param depth 当前标签\r\n     * @returns {string} 解析的目录内容\r\n     */\r\n  this.analysis = function (last, depth) {\r\n    var tocStr = '<ul class=\\'menu-list\\'>'\r\n    while (this.eIndex < this.elementList.length) {\r\n      var elem = this.elementList[this.eIndex]\r\n      // 取得当前元素在标签列表中所属的位置\r\n      var n = this.tocList.indexOf(elem.tagName)\r\n      // 当级别大于最大级别，小于当前级别时，就当做当前级别来处理，并将新的级别设置为新级别\r\n      if (n > last && n <= depth) {\r\n        depth = n\r\n        var id = elem.id\r\n        var text = elem.innerText\r\n        // 标签不存在id，设置id\r\n        if (id == null || id === '') {\r\n          id = text + '_' + this.eIndex\r\n          elem.setAttribute('id', id)\r\n        }\r\n        tocStr += `<li><a data-id=\"#${id}\"><i class=\"ri-attachment-2\"></i>${text}</a>`\r\n        this.eIndex++\r\n        if (this.eIndex >= this.elementList.length) {\r\n          tocStr += '</li>'\r\n          break\r\n        }\r\n        n = this.tocList.indexOf(this.elementList[this.eIndex].tagName)\r\n        // 如果下一个元素的序号大于当前元素的序号，那么元素为子元素，需要递归获取\r\n        if (n > depth) {\r\n          tocStr += this.analysis(depth, n)\r\n        }\r\n        tocStr += '</li>'\r\n      } else if (n <= last) {\r\n        // 如果这个元素的序号已经小于最小序号了，那说明这个元素已经外面一层的元素了\r\n        break\r\n      }\r\n    }\r\n    return tocStr + '</ul>'\r\n  }\r\n}\r\nconst observers = []\r\nfunction register($toc) {\r\n  // toc滚动时间和偏移量\r\n  const time = 20\r\n  const headingsOffset = 50\r\n  const currentInView = new Set()\r\n  const headingToMenu = new Map()\r\n  const $menus = Array.from($toc.querySelectorAll('.menu-list > li > a'))\r\n\r\n  for (const $menu of $menus) {\r\n    const elementId = $menu.getAttribute('data-id').trim().slice(1)\r\n    const $heading = document.getElementById(elementId)\r\n    if ($heading) {\r\n      headingToMenu.set($heading, $menu)\r\n    }\r\n  }\r\n\r\n  const $headings = Array.from(headingToMenu.keys())\r\n\r\n  const callback = (entries) => {\r\n    for (const entry of entries) {\r\n      if (entry.isIntersecting) {\r\n        currentInView.add(entry.target)\r\n      } else {\r\n        currentInView.delete(entry.target)\r\n      }\r\n    }\r\n    let $heading\r\n    if (currentInView.size) {\r\n      // heading is the first in-view heading\r\n      $heading = [...currentInView].sort(($el1, $el2) => $el1.offsetTop - $el2.offsetTop)[0]\r\n    } else if ($headings.length) {\r\n      // heading is the closest heading above the viewport top\r\n      $heading = $headings\r\n        .filter(($heading) => $heading.offsetTop < window.scrollY)\r\n        .sort(($el1, $el2) => $el2.offsetTop - $el1.offsetTop)[0]\r\n    }\r\n    if ($heading && headingToMenu.has($heading)) {\r\n      $menus.forEach(($menu) => $menu.classList.remove('is-active'))\r\n\r\n      const $menu = headingToMenu.get($heading)\r\n      $menu.classList.add('is-active')\r\n      let $menuList = $menu.parentElement.parentElement\r\n      while (\r\n        $menuList.classList.contains('menu-list') &&\r\n                $menuList.parentElement.tagName.toLowerCase() === 'li'\r\n      ) {\r\n        $menuList.parentElement.children[0].classList.add('is-active')\r\n        $menuList = $menuList.parentElement.parentElement\r\n      }\r\n    }\r\n  }\r\n  const observer = new IntersectionObserver(callback, { threshold: 0 })\r\n\r\n  for (const $heading of $headings) {\r\n    observer.observe($heading)\r\n    // smooth scroll to the heading\r\n    if (headingToMenu.has($heading)) {\r\n      const $menu = headingToMenu.get($heading)\r\n      $menu.addEventListener('click', () => {\r\n        var element = document.getElementById($menu.getAttribute('data-id').substring(1))\r\n        let rect = element.getBoundingClientRect()\r\n        let currentY = window.pageYOffset\r\n        let targetY = currentY + rect.top - headingsOffset\r\n        let speed = (targetY - currentY) / time\r\n        let offset = currentY > targetY ? -1 : 1\r\n        let requestId\r\n        function step(timestamp) {\r\n          currentY+=speed\r\n          if(currentY * offset < targetY * offset){\r\n            window.scrollTo(0,currentY)\r\n            requestId=window.requestAnimationFrame(step)\r\n          }else{\r\n            window.scrollTo(0,targetY)\r\n            window.cancelAnimationFrame(requestId)\r\n          }\r\n        }\r\n        window.requestAnimationFrame(step)\r\n      })\r\n    }\r\n    if (headingToMenu.has($heading)) {\r\n      $heading.style.scrollMargin = '1em'\r\n    }\r\n  }\r\n  observers.push(observer)\r\n}\r\nBtoc.init = function (params) {\r\n  const tocList = params['tocList']\r\n  const contentElement = params['contentElement']\r\n  const tocSelect = params['tocElement']\r\n  if (tocList == null || tocList.length === 0 || contentElement == null) {\r\n    $(tocSelect).children().remove()\r\n    return false\r\n  }\r\n  for (var i = 0; i < tocList.length; i++) {\r\n    tocList[i] = tocList[i].toUpperCase()\r\n  }\r\n  let tocContent = new Btoc(tocList, contentElement).build()\r\n  $(tocSelect).html(tocContent)\r\n}\r\n\r\nwindow.tocPjax = function () {\r\n  observers.forEach(observer => {\r\n    observer.disconnect()\r\n  })\r\n  observers.splice(0)\r\n  Btoc.init({\r\n    tocList: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\r\n    contentElement: $('.main-content:not(.not-toc)')[0],\r\n    tocElement: '.toc-content'\r\n  })\r\n  if (typeof window.IntersectionObserver === 'undefined') {\r\n    return\r\n  }\r\n  document.querySelectorAll('.toc-content').forEach(register)\r\n}\r\n\n\n//# sourceURL=webpack://halo-theme-dream2.0-plus/./src/js/btoc.js?")}},__webpack_exports__={};__webpack_modules__["./src/js/btoc.js"]()})();