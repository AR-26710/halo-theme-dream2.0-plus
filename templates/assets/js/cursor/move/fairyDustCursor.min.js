(()=>{var __webpack_modules__={"./src/js/cursor/move/fairyDustCursor.js":()=>{eval("function fairyDustCursor(options) {\r\n  let possibleColors = (options && options.colors) || [\r\n    '#D61C59',\r\n    '#E7D84B',\r\n    '#1B8798',\r\n  ]\r\n  let hasWrapperEl = options && options.element\r\n  let element = hasWrapperEl || document.body\r\n\r\n  let width = window.innerWidth\r\n  let height = window.innerHeight\r\n  const cursor = { x: width / 2, y: width / 2 }\r\n  const lastPos = { x: width / 2, y: width / 2 }\r\n  const particles = []\r\n  const canvImages = []\r\n  let canvas, context\r\n\r\n  const char = '*'\r\n\r\n  function init() {\r\n    canvas = document.createElement('canvas')\r\n    context = canvas.getContext('2d')\r\n    canvas.style.top = '0px'\r\n    canvas.style.left = '0px'\r\n    canvas.style.pointerEvents = 'none'\r\n\r\n    if (hasWrapperEl) {\r\n      canvas.style.position = 'absolute'\r\n      element.appendChild(canvas)\r\n      canvas.width = element.clientWidth\r\n      canvas.height = element.clientHeight\r\n    } else {\r\n      canvas.style.position = 'fixed'\r\n      element.appendChild(canvas)\r\n      canvas.width = width\r\n      canvas.height = height\r\n    }\r\n\r\n    context.font = '21px serif'\r\n    context.textBaseline = 'middle'\r\n    context.textAlign = 'center'\r\n\r\n    possibleColors.forEach((color) => {\r\n      let measurements = context.measureText(char)\r\n      let bgCanvas = document.createElement('canvas')\r\n      let bgContext = bgCanvas.getContext('2d')\r\n\r\n      bgCanvas.width = measurements.width\r\n      bgCanvas.height =\r\n        measurements.actualBoundingBoxAscent +\r\n        measurements.actualBoundingBoxDescent\r\n\r\n      bgContext.fillStyle = color\r\n      bgContext.textAlign = 'center'\r\n      bgContext.font = '21px serif'\r\n      bgContext.textBaseline = 'middle'\r\n      bgContext.fillText(\r\n        char,\r\n        bgCanvas.width / 2,\r\n        measurements.actualBoundingBoxAscent\r\n      )\r\n\r\n      canvImages.push(bgCanvas)\r\n    })\r\n\r\n    bindEvents()\r\n    loop()\r\n  }\r\n\r\n  // Bind events that are needed\r\n  function bindEvents() {\r\n    element.addEventListener('mousemove', onMouseMove)\r\n    element.addEventListener('touchmove', onTouchMove, { passive: true })\r\n    element.addEventListener('touchstart', onTouchMove, { passive: true })\r\n    window.addEventListener('resize', onWindowResize)\r\n  }\r\n\r\n  function onWindowResize(e) {\r\n    width = window.innerWidth\r\n    height = window.innerHeight\r\n\r\n    if (hasWrapperEl) {\r\n      canvas.width = element.clientWidth\r\n      canvas.height = element.clientHeight\r\n    } else {\r\n      canvas.width = width\r\n      canvas.height = height\r\n    }\r\n  }\r\n\r\n  function onTouchMove(e) {\r\n    if (e.touches.length > 0) {\r\n      for (let i = 0; i < e.touches.length; i++) {\r\n        addParticle(\r\n          e.touches[i].clientX,\r\n          e.touches[i].clientY,\r\n          canvImages[Math.floor(Math.random() * canvImages.length)]\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  function onMouseMove(e) {\r\n    window.requestAnimationFrame(() => {\r\n      if (hasWrapperEl) {\r\n        const boundingRect = element.getBoundingClientRect()\r\n        cursor.x = e.clientX - boundingRect.left\r\n        cursor.y = e.clientY - boundingRect.top\r\n      } else {\r\n        cursor.x = e.clientX\r\n        cursor.y = e.clientY\r\n      }\r\n\r\n      const distBetweenPoints = Math.hypot(\r\n        cursor.x - lastPos.x,\r\n        cursor.y - lastPos.y\r\n      )\r\n\r\n      if (distBetweenPoints > 1.5) {\r\n        addParticle(\r\n          cursor.x,\r\n          cursor.y,\r\n          canvImages[Math.floor(Math.random() * possibleColors.length)]\r\n        )\r\n\r\n        lastPos.x = cursor.x\r\n        lastPos.y = cursor.y\r\n      }\r\n    })\r\n  }\r\n\r\n  function addParticle(x, y, color) {\r\n    particles.push(new Particle(x, y, color))\r\n  }\r\n\r\n  function updateParticles() {\r\n    context.clearRect(0, 0, width, height)\r\n\r\n    // Update\r\n    for (let i = 0; i < particles.length; i++) {\r\n      particles[i].update(context)\r\n    }\r\n\r\n    // Remove dead particles\r\n    for (let i = particles.length - 1; i >= 0; i--) {\r\n      if (particles[i].lifeSpan < 0) {\r\n        particles.splice(i, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  function loop() {\r\n    updateParticles()\r\n    requestAnimationFrame(loop)\r\n  }\r\n\r\n  function Particle(x, y, canvasItem) {\r\n    const lifeSpan = Math.floor(Math.random() * 30 + 60)\r\n    this.initialLifeSpan = lifeSpan //\r\n    this.lifeSpan = lifeSpan //ms\r\n    this.velocity = {\r\n      x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2),\r\n      y: Math.random() * 0.7 + 0.9,\r\n    }\r\n    this.position = { x: x, y: y }\r\n    this.canv = canvasItem\r\n\r\n    this.update = function (context) {\r\n      this.position.x += this.velocity.x\r\n      this.position.y += this.velocity.y\r\n      this.lifeSpan--\r\n\r\n      this.velocity.y += 0.02\r\n\r\n      const scale = Math.max(this.lifeSpan / this.initialLifeSpan, 0)\r\n\r\n      context.drawImage(\r\n        this.canv,\r\n        this.position.x - (this.canv.width / 2) * scale,\r\n        this.position.y - this.canv.height / 2,\r\n        this.canv.width * scale,\r\n        this.canv.height * scale\r\n      )\r\n    }\r\n  }\r\n\r\n  init()\r\n}\r\nnew fairyDustCursor()\r\n\n\n//# sourceURL=webpack://halo-theme-dream2.0-plus/./src/js/cursor/move/fairyDustCursor.js?")}},__webpack_exports__={};__webpack_modules__["./src/js/cursor/move/fairyDustCursor.js"]()})();